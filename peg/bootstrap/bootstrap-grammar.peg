package main

{
func main() {
    dbgFlag := flag.Bool("debug", false, "set debug mode")
    //noBuildFlag := flag.Bool("x", false, "do not build, only parse")
    flag.Parse()

	if flag.NArg() > 1 {
		fmt.Fprintln(os.Stderr, "USAGE: <cmd> FILE")
		os.Exit(1)
	}

	var in io.Reader

	nm := "stdin"
	if flag.NArg() == 1 {
		f, err := os.Open(flag.Arg(0))
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(2)
		}
		defer f.Close()
		in = f
		nm = flag.Arg(0)
	} else {
		in = bufio.NewReader(os.Stdin)
	}

    debug = *dbgFlag
	res, err := Parse(nm, in)
	if err != nil {
		log.Fatal(err)
	}
    fmt.Println(res)
}

func (c *current) astPos() ast.Pos {
    return ast.Pos{Line: c.pos.line, Col: c.pos.col, Off: c.pos.offset}
}
}

Grammar ← __ "package" __ pkg:IdentifierName __ initializer:( Initializer __ )? rules:( Rule __ )+ {
    pos := c.astPos()

    // create the package
    pack := ast.NewPackage(pos)
    pack.Name = pkg
    // create the grammar, assign its initializer
    g := ast.NewGrammar(pos, pack)
    initSlice := initializer.([]interface{})
    if len(initSlice) > 0 {
        g.Init = initSlice[0].(*ast.CodeBlock)
    }

    rulesSlice := rules.([]interface{})
    g.Rules = make([]*ast.Rule, len(rulesSlice))
    for i, duo := range rulesSlice {
        g.Rules[i] = duo.([]interface{})[0].(*ast.Rule)
    }

    return g, nil
}

Initializer ← code:CodeBlock EOS {
    return code, nil
}

Rule ← name:IdentifierName __ display:( StringLiteral __ )? RuleDefOp __ expr:Expression EOS {
    pos := c.astPos()

    rule := ast.NewRule(pos, name)
    displaySlice := display.([]interface{})
    if len(displaySlice) > 0 {
        rule.DisplayName = displaySlice[0].(*ast.StringLit)
    }
    rule.Expr = expr

    return rule, nil
}

Expression ← ChoiceExpr

ChoiceExpr ← first:ActionExpr rest:( __ "/" __ ActionExpr )* {
    restSlice := rest.([]interface{})
    if len(restSlice) == 0 {
        return first, nil
    }

    pos := c.astPos()
    choice := ast.NewChoiceExpr(pos)
    choice.Alternatives = []ast.Expression{first}
    for _, sl := range restSlice {
        choice.Alternatives = append(choice.Alternatives, sl[3].(ast.Expression))
    }
    return choice, nil
}

ActionExpr ← expr:SeqExpr code:( __ CodeBlock )? {
    if code == nil {
        return expr, nil
    }

    pos := c.astPos()
    act := ast.NewActionExpr(pos)
    act.Expr = expr
    codeSlice := code.([]interface{})
    act.Code = codeSlice[1].(*ast.CodeBlock)

    return act, nil
}

SeqExpr ← first:LabeledExpr rest:( __ LabeledExpr )* {
    if len(rest) == 0 {
        return first, nil
    }
    seq := ast.NewSeqExpr(c.astPos())
    seq.Exprs = []ast.Expression{first}
    restSlice := rest.([]interface{})
    for _, sl := range restSlice {
        seq.Exprs = append(seq.Exprs, sl.([]interface{})[1].(ast.Expression))
    }
    return seq, nil
}

LabeledExpr ← label:Identifier __ ':' __ expr:PrefixedExpr {
    pos := c.astPos()
    lab := ast.NewLabeledExpr(pos)
    lab.Label = label
    lab.Expr = expr
    return lab, nil
} / PrefixedExpr

PrefixedExpr ← op:PrefixedOp __ expr:SuffixedExpr {
    pos := c.astPos()
    if op == "&" {
        and := ast.NewAndExpr(pos)
        and.Expr = expr
        return and, nil
    }
    not := ast.NewNotExpr(pos)
    not.Expr = expr
    return not, nil
} / SuffixedExpr

PrefixedOp ← ( '&' / '!' ) {
    return string(c.text), nil
}

SuffixedExpr ← expr:PrimaryExpr __ op:SuffixedOp {
    pos := c.astPos()
    switch op {
    case "?":
        zero := ast.NewZeroOrOneExpr(pos)
        zero.Expr = expr
        return zero, nil
    case "*":
        zero := ast.NewZeroOrMoreExpr(pos)
        zero.Expr = expr
        return zero, nil
    case "+":
        one := ast.NewOneOrMoreExpr(pos)
        one.Expr = expr
        return one, nil
    default:
        return nil, errors.New("unknown operator: " + op)
    }
} / PrimaryExpr 

SuffixedOp ← ( '?' / '*' / '+' ) {
    return string(c.text), nil
}

PrimaryExpr ← LitMatcher / CharClassMatcher / AnyMatcher / RuleRefExpr / SemanticPredExpr / "(" __ expr:Expression __ ")" {
    return expr, nil
}
RuleRefExpr ← name:IdentifierName !( __ ( StringLiteral __ )? RuleDefOp ) {
    ref := ast.NewRuleRefExpr(c.astPos())
    ref.Name = name
    return ref, nil
}
SemanticPredExpr ← op:SemanticPredOp __ code:CodeBlock {
    if op == "&" {
        and := ast.NewAndCodeExpr(c.astPos())
        and.Code = code
        return and, nil
    }
    not := ast.NewNotCodeExpr(c.astPos())
    not.Code = code
    return not, nil
}
SemanticPredOp ← ( '&' / '!' ) {
    return string(c.text), nil
}

RuleDefOp ← '=' / "<-" / '\u2190' / '\u27f5'

SourceChar ← .
Comment ← MultiLineComment / SingleLineComment
MultiLineComment ← "/*" ( !"*/" SourceChar )* "*/"
MultiLineCommentNoLineTerminator ← "/*" ( !( "*/" / EOL ) SourceChar )* "*/"
SingleLineComment ← "//" ( !EOL SourceChar )*

Identifier ← IdentifierName
IdentifierName ← IdentifierStart IdentifierPart* {
    return ast.NewIdentifier(c.astPos(), string(c.text)), nil
}
IdentifierStart ← [a-z_]i
IdentifierPart ← IdentifierStart / [0-9]

// TODO : reserved words...

LitMatcher ← lit:StringLiteral ignore:"i"? {
    m := ast.NewLitMatcher(c.astPos(), lit.(*ast.StringLiteral).Val)
    m.IgnoreCase = ignore != nil
    return m, nil
}
StringLiteral ← ( '"' DoubleStringChar* '"' / "'" SingleStringChar "'" ) {
    return ast.NewStringLit(c.astPos(), string(c.text)), nil
}
DoubleStringChar ← !( '"' / "\\" / EOL ) SourceChar
SingleStringChar ← !( "'" / "\\" / EOL ) SourceChar

// TODO : escape sequences, character classes...
/*

CharClassMatcher = "[" "^"? ( ClassCharRange / ClassChar )* "]" "i"? sp
ClassCharRange = ClassChar "-" ClassChar
ClassChar = !( "]" / "\\" / EOL ) SourceChar

ClassEscapeSequence ← ']' { return string(c.text), nil } / SingleCharEscape / UnicodeClassEscape / OctalEscape / HexEscape / LongUnicodeEscape / ShortUnicodeEscape

SingleCharEscape ← 'a' / 'b' / 'n' / 'f' / 'r' / 't' / 'v' / '\\' {
    rn, _, _, err := strconv.UnquoteChar("\\" + string(c.text), '\'')
    return rn, err
}
UnicodeClassEscape ← 'p' class:( SingleCharUnicodeClass / '{' UnicodeClass '}' ) {
    vals := class.([]interface{})
    var val string
    if len(vals) == 1 {
        val = vals[0].(string)
    } else {
        val = vals[1].(string)
    }
    return val, nil
}
OctalEscape ← OctalDigit OctalDigit OctalDigit {
    rn, _, _, err := strconv.UnquoteChar("\\" + string(c.text), '\'')
    return rn, err
}
HexEscape ← 'x' HexDigit HexDigit {
    rn, _, _, err := strconv.UnquoteChar("\\" + string(c.text), '\'')
    return rn, err
}
LongUnicodeEscape ← 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit {
    rn, _, _, err := strconv.UnquoteChar("\\" + string(c.text), '\'')
    return rn, err
}
ShortUnicodeEscape ← 'u' HexDigit HexDigit HexDigit HexDigit {
    rn, _, _, err := strconv.UnquoteChar("\\" + string(c.text), '\'')
    return rn, err
}

OctalDigit ← [0-7]
DecimalDigit ← [0-9]
HexDigit ← [0-9a-f]i
*/

// AnyMatcher returns *ast.AnyMatcher
AnyMatcher ← "." {
    any := ast.NewAnyMatcher(c.astPos(), ".")
    return any, nil
}

// CodeBlock returns *ast.CodeBlock
CodeBlock ← "{" Code "}" {
    pos := c.astPos()
    cb := ast.NewCodeBlock(pos, string(c.text))
    return cb, nil
}

Code ← ( ( [^{}] SourceCharacter )+ / "{" Code "}" )*

__ ← ( Whitespace / EOL / Comment )*
_ ← ( Whitespace / MultiLineCommentNoLineTerminator )*

Whitespace ← [ \n\t\r]
EOL ← '\n'
EOS ← __ ';' / _ SingleLineComment? EOL / __ EOF
EOF ← !.

