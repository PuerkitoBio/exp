package main

{
func main() {
    dbgFlag := flag.Bool("debug", false, "set debug mode")
    //noBuildFlag := flag.Bool("x", false, "do not build, only parse")
    flag.Parse()

	if flag.NArg() > 1 {
		fmt.Fprintln(os.Stderr, "USAGE: <cmd> FILE")
		os.Exit(1)
	}

	var in io.Reader

	nm := "stdin"
	if flag.NArg() == 1 {
		f, err := os.Open(flag.Arg(0))
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(2)
		}
		defer f.Close()
		in = f
		nm = flag.Arg(0)
	} else {
		in = bufio.NewReader(os.Stdin)
	}

    debug = *dbgFlag
	res, err := Parse(nm, in)
	if err != nil {
		log.Fatal(err)
	}
    fmt.Println(res)
}

func toASTPos(c *current) ast.Pos {
    return ast.Pos{Line: c.pos.line, Col: c.pos.col, Off: c.pos.offset}
}
}

Grammar = sp "package" sp pkg:IdentifierName sp initializer:(Initializer sp)? rules:(Rule sp)+ {
    pos := ast.Pos{Line: c.pos.line, Col: c.pos.col, Off: c.pos.offset}

    // create the package identifier
    nm := ast.NewIdentifier(pos, pkg.(string))
    // create the package
    pack := ast.NewPackage(pos)
    pack.Name = nm
    // create the grammar, assign its initializer
    g := ast.NewGrammar(pos, pack)
    if initializer != nil {
        g.Init = initializer.([]interface{})[0].(*ast.CodeBlock)
    }

    rulesTuples := rules.([]interface{})
    g.Rules = make([]*ast.Rule, len(rulesTuples))
    for i, duo := range rulesTuples {
        g.Rules[i] = duo.([]interface{})[0].(*ast.Rule)
        fmt.Println("rule: ", g.Rules[i].Name.Val)
    }

    return g, nil
}

Initializer = CodeBlock {
    pos := ast.Pos{Line: c.pos.line, Col: c.pos.col, Off: c.pos.offset}
    cb := ast.NewCodeBlock(pos, string(c.text))
    return cb, nil
}

Rule = ident:IdentifierName sp display:( StringLiteral sp )? RuleDefOp expr:Expression EndOfRule {
    pos := ast.Pos{Line: c.pos.line, Col: c.pos.col, Off: c.pos.offset}

    // create the rule identifier
    nm := ast.NewIdentifier(pos, ident.(string))
    rule := ast.NewRule(pos, nm)
    if display != nil {
        rule.DisplayName = display.([]interface{})[0].(*ast.StringLit)
    }
    // TODO : expr

    return rule, nil
}

Expression = ChoiceExpr

ChoiceExpr = ActionExpr ( "/" sp ActionExpr )*

ActionExpr = SeqExpr ( CodeBlock )?

SeqExpr = LabeledExpr ( LabeledExpr )*

LabeledExpr = Identifier ":" sp PrefixedExpr / PrefixedExpr

PrefixedExpr = PrefixedOp SuffixedExpr / SuffixedExpr

PrefixedOp = ( "&" / "!" ) sp

SuffixedExpr = PrimaryExpr SuffixedOp / PrimaryExpr 

SuffixedOp = ( "?" / "*" / "+" ) sp

PrimaryExpr = LitMatcher / CharClassMatcher / AnyMatcher / RuleRefExpr / SemanticPredExpr / "(" sp Expression ")" sp

RuleRefExpr = IdentifierName !( ( StringLiteral )? "=" )

SemanticPredExpr = SemanticPredOp CodeBlock

SemanticPredOp = ( "&" / "!" ) sp

RuleDefOp ← ( '=' / "<-" / '\u2190' / '\u27f5' )

SourceChar ← .
Comment ← MultiLineComment / SingleLineComment
MultiLineComment ← "/*" ( !"*/" SourceChar )* "*/"
MultiLineCommentNoLineTerminator ← "/*" ( !( "*/" / EOL ) SourceChar )* "*/"
SingleLineComment ← "//" ( !EOL SourceChar )*

Identifier ← IdentifierName
IdentifierName ← IdentifierStart IdentifierPart* {
    return ast.NewIdentifier(toASTPos(c), string(c.text)), nil
}
IdentifierStart ← [a-z_]i
IdentifierPart ← IdentifierStart / [0-9]

// TODO : reserved words...

LitMatcher ← lit:StringLiteral ignore:"i"? {
    m := ast.NewLitMatcher(toASTPos(c), lit.(*ast.StringLiteral).Val)
    m.IgnoreCase = ignore != nil
    return m, nil
}
StringLiteral ← ( '"' DoubleStringChar* '"' / "'" SingleStringChar* "'" ) {
    return ast.NewStringLit(toASTPos(c), string(c.text)), nil
}
DoubleStringChar ← !( '"' / "\\" / EOL ) SourceChar
SingleStringChar ← !( "'" / "\\" / EOL ) SourceChar

// TODO : escape sequences, character classes...
/*

CharClassMatcher = "[" "^"? ( ClassCharRange / ClassChar )* "]" "i"? sp
ClassCharRange = ClassChar "-" ClassChar
ClassChar = !( "]" / "\\" / EOL ) SourceChar

ClassEscapeSequence ← ']' { return string(c.text), nil } / SingleCharEscape / UnicodeClassEscape / OctalEscape / HexEscape / LongUnicodeEscape / ShortUnicodeEscape

SingleCharEscape ← 'a' / 'b' / 'n' / 'f' / 'r' / 't' / 'v' / '\\' {
    rn, _, _, err := strconv.UnquoteChar("\\" + string(c.text), '\'')
    return rn, err
}
UnicodeClassEscape ← 'p' class:( SingleCharUnicodeClass / '{' UnicodeClass '}' ) {
    vals := class.([]interface{})
    var val string
    if len(vals) == 1 {
        val = vals[0].(string)
    } else {
        val = vals[1].(string)
    }
    return val, nil
}
OctalEscape ← OctalDigit OctalDigit OctalDigit {
    rn, _, _, err := strconv.UnquoteChar("\\" + string(c.text), '\'')
    return rn, err
}
HexEscape ← 'x' HexDigit HexDigit {
    rn, _, _, err := strconv.UnquoteChar("\\" + string(c.text), '\'')
    return rn, err
}
LongUnicodeEscape ← 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit {
    rn, _, _, err := strconv.UnquoteChar("\\" + string(c.text), '\'')
    return rn, err
}
ShortUnicodeEscape ← 'u' HexDigit HexDigit HexDigit HexDigit {
    rn, _, _, err := strconv.UnquoteChar("\\" + string(c.text), '\'')
    return rn, err
}

OctalDigit ← [0-7]
DecimalDigit ← [0-9]
HexDigit ← [0-9a-f]i
*/

// AnyMatcher returns *ast.AnyMatcher
AnyMatcher ← "." {
    any := ast.NewAnyMatcher(toASTPos(c), ".")
    return any, nil
}

// CodeBlock returns *ast.CodeBlock
CodeBlock ← "{" Code "}" {
    pos := toASTPos(c)
    cb := ast.NewCodeBlock(pos, string(c.text))
    return cb, nil
}

Code ← ( ( [^{}] SourceCharacter )+ / "{" Code "}" )*

__ ← ( Whitespace / EOL / Comment )*
_ ← ( Whitespace / MultiLineCommentNoLineTerminator )*

Whitespace ← [ \n\t\r]
EOL ← '\n'
EOS ← __ ';' / _ SingleLineComment? EOL / __ EOF
EOF ← !.

