{
package main
}

Grammar ← __ initializer:( Initializer __ )? rules:( Rule __ )+ {
    pos := c.astPos()

    // create the grammar, assign its initializer
    g := ast.NewGrammar(pos)
    initSlice := toIfaceSlice(initializer)
    if len(initSlice) > 0 {
        g.Init = initSlice[0].(*ast.CodeBlock)
    }

    rulesSlice := toIfaceSlice(rules)
    g.Rules = make([]*ast.Rule, len(rulesSlice))
    for i, duo := range rulesSlice {
        g.Rules[i] = duo.([]interface{})[0].(*ast.Rule)
    }

    return g, nil
}

Initializer ← code:CodeBlock EOS {
    return code, nil
}

Rule ← name:IdentifierName __ display:( StringLiteral __ )? RuleDefOp __ expr:Expression EOS {
    pos := c.astPos()

    rule := ast.NewRule(pos, name.(*ast.Identifier))
    displaySlice := toIfaceSlice(display)
    if len(displaySlice) > 0 {
        rule.DisplayName = displaySlice[0].(*ast.StringLit)
    }
    rule.Expr = expr.(ast.Expression)

    return rule, nil
}

Expression ← ChoiceExpr

ChoiceExpr ← first:ActionExpr rest:( __ "/" __ ActionExpr )* {
    restSlice := toIfaceSlice(rest)
    if len(restSlice) == 0 {
        return first, nil
    }

    pos := c.astPos()
    choice := ast.NewChoiceExpr(pos)
    choice.Alternatives = []ast.Expression{first.(ast.Expression)}
    for _, sl := range restSlice {
        choice.Alternatives = append(choice.Alternatives, sl.([]interface{})[3].(ast.Expression))
    }
    return choice, nil
}

ActionExpr ← expr:SeqExpr code:( __ CodeBlock )? {
    if code == nil {
        return expr, nil
    }

    pos := c.astPos()
    act := ast.NewActionExpr(pos)
    act.Expr = expr.(ast.Expression)
    codeSlice := toIfaceSlice(code)
    act.Code = codeSlice[1].(*ast.CodeBlock)

    return act, nil
}

SeqExpr ← first:LabeledExpr rest:( __ LabeledExpr )* {
    restSlice := toIfaceSlice(rest)
    if len(restSlice) == 0 {
        return first, nil
    }
    seq := ast.NewSeqExpr(c.astPos())
    seq.Exprs = []ast.Expression{first.(ast.Expression)}
    for _, sl := range restSlice {
        seq.Exprs = append(seq.Exprs, sl.([]interface{})[1].(ast.Expression))
    }
    return seq, nil
}

LabeledExpr ← label:Identifier __ ':' __ expr:PrefixedExpr {
    pos := c.astPos()
    lab := ast.NewLabeledExpr(pos)
    lab.Label = label.(*ast.Identifier)
    lab.Expr = expr.(ast.Expression)
    return lab, nil
} / PrefixedExpr

PrefixedExpr ← op:PrefixedOp __ expr:SuffixedExpr {
    pos := c.astPos()
    opStr := op.(string)
    if opStr == "&" {
        and := ast.NewAndExpr(pos)
        and.Expr = expr.(ast.Expression)
        return and, nil
    }
    not := ast.NewNotExpr(pos)
    not.Expr = expr.(ast.Expression)
    return not, nil
} / SuffixedExpr

PrefixedOp ← ( '&' / '!' ) {
    return string(c.text), nil
}

SuffixedExpr ← expr:PrimaryExpr __ op:SuffixedOp {
    pos := c.astPos()
    opStr := op.(string)
    switch opStr {
    case "?":
        zero := ast.NewZeroOrOneExpr(pos)
        zero.Expr = expr.(ast.Expression)
        return zero, nil
    case "*":
        zero := ast.NewZeroOrMoreExpr(pos)
        zero.Expr = expr.(ast.Expression)
        return zero, nil
    case "+":
        one := ast.NewOneOrMoreExpr(pos)
        one.Expr = expr.(ast.Expression)
        return one, nil
    default:
        return nil, errors.New("unknown operator: " + opStr)
    }
} / PrimaryExpr 

SuffixedOp ← ( '?' / '*' / '+' ) {
    return string(c.text), nil
}

PrimaryExpr ← LitMatcher / CharClassMatcher / AnyMatcher / RuleRefExpr / SemanticPredExpr / "(" __ expr:Expression __ ")" {
    return expr, nil
}
RuleRefExpr ← name:IdentifierName !( __ ( StringLiteral __ )? RuleDefOp ) {
    ref := ast.NewRuleRefExpr(c.astPos())
    ref.Name = name.(*ast.Identifier)
    return ref, nil
}
SemanticPredExpr ← op:SemanticPredOp __ code:CodeBlock {
    opStr := op.(string)
    if opStr == "&" {
        and := ast.NewAndCodeExpr(c.astPos())
        and.Code = code.(*ast.CodeBlock)
        return and, nil
    }
    not := ast.NewNotCodeExpr(c.astPos())
    not.Code = code.(*ast.CodeBlock)
    return not, nil
}
SemanticPredOp ← ( '&' / '!' ) {
    return string(c.text), nil
}

RuleDefOp ← '=' / "<-" / '\u2190' / '\u27f5'

SourceChar ← .
Comment ← MultiLineComment / SingleLineComment
MultiLineComment ← "/*" ( !"*/" SourceChar )* "*/"
MultiLineCommentNoLineTerminator ← "/*" ( !( "*/" / EOL ) SourceChar )* "*/"
SingleLineComment ← "//" ( !EOL SourceChar )*

// TODO : reserved keywords
Identifier ← IdentifierName
IdentifierName ← IdentifierStart IdentifierPart* {
    return ast.NewIdentifier(c.astPos(), string(c.text)), nil
}
IdentifierStart ← [\pL_]
IdentifierPart ← IdentifierStart / [\p{Nd}]

LitMatcher ← lit:StringLiteral ignore:"i"? {
    rawStr := lit.(*ast.StringLit).Val
	s, err := strconv.Unquote(rawStr)
    if err != nil {
        return nil, err
    }
    m := ast.NewLitMatcher(c.astPos(), s)
    m.IgnoreCase = ignore != nil
    return m, nil
}
StringLiteral ← ( '"' DoubleStringChar* '"' / "'" SingleStringChar "'" / '`' RawStringChar '`' ) {
    return ast.NewStringLit(c.astPos(), string(c.text)), nil
}
DoubleStringChar ← !( '"' / "\\" / EOL ) SourceChar / "\\" DoubleStringEscape
SingleStringChar ← !( "'" / "\\" / EOL ) SourceChar / "\\" SingleStringEscape
RawStringChar ← !'`' SourceChar

DoubleStringEscape ← "'" / CommonEscapeSequence
SingleStringEscape ← '"' / CommonEscapeSequence

CommonEscapeSequence ← SingleCharEscape / OctalEscape / HexEscape / LongUnicodeEscape / ShortUnicodeEscape
SingleCharEscape ← 'a' / 'b' / 'n' / 'f' / 'r' / 't' / 'v' / '\\'
OctalEscape ← OctalDigit OctalDigit OctalDigit
HexEscape ← 'x' HexDigit HexDigit
LongUnicodeEscape ← 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit
ShortUnicodeEscape ← 'u' HexDigit HexDigit HexDigit HexDigit

OctalDigit ← [0-7]
DecimalDigit ← [0-9]
HexDigit ← [0-9a-f]i

CharClassMatcher ← '[' ( ClassCharRange / ClassChar / "\\" UnicodeClassEscape )* ']' 'i'? {
    pos := c.astPos()
    cc := ast.NewCharClassMatcher(pos, string(c.text))
    return cc, nil
}
ClassCharRange ← ClassChar '-' ClassChar
ClassChar ← !( "]" / "\\" / EOL ) SourceChar / "\\" CharClassEscape
CharClassEscape ← ']' / CommonEscapeSequence

UnicodeClassEscape ← 'p' ( SingleCharUnicodeClass / '{' UnicodeClass '}' )
SingleCharUnicodeClass ← [LMNCPZS]

UnicodeClass ← "ASCII_Hex_Digit"

/*
    / "Arabic"
    / "Armenian"
    / "Avestan"
    / "Balinese"
    / "Bamum"
    / "Bassa_Vah"
    / "Batak"
    / "Bengali"
    / "Bidi_Control"
    / "Bopomofo"
    / "Brahmi"
    / "Braille"
    / "Buginese"
    / "Buhid"
    / "C"
    / "Canadian_Aboriginal"
    / "Carian"
    / "Caucasian_Albanian"
    / "Cc"
    / "Cf"
    / "Chakma"
    / "Cham"
    / "Cherokee"
    / "Co"
    / "Common"
    / "Coptic"
    / "Cs"
    / "Cuneiform"
    / "Cypriot"
    / "Cyrillic"
    / "Dash"
    / "Deprecated"
    / "Deseret"
    / "Devanagari"
    / "Diacritic"
    / "Duployan"
    / "Egyptian_Hieroglyphs"
    / "Elbasan"
    / "Ethiopic"
    / "Extender"
    / "Georgian"
    / "Glagolitic"
    / "Gothic"
    / "Grantha"
    / "Greek"
    / "Gujarati"
    / "Gurmukhi"
    / "Han"
    / "Hangul"
    / "Hanunoo"
    / "Hebrew"
    / "Hex_Digit"
    / "Hiragana"
    / "Hyphen"
    / "IDS_Binary_Operator"
    / "IDS_Trinary_Operator"
    / "Ideographic"
    / "Imperial_Aramaic"
    / "Inherited"
    / "Inscriptional_Pahlavi"
    / "Inscriptional_Parthian"
    / "Javanese"
    / "Join_Control"
    / "Kaithi"
    / "Kannada"
    / "Katakana"
    / "Kayah_Li"
    / "Kharoshthi"
    / "Khmer"
    / "Khojki"
    / "Khudawadi"
    / "L"
    / "Lao"
    / "Latin"
    / "Lepcha"
    / "Limbu"
    / "Linear_A"
    / "Linear_B"
    / "Lisu"
    / "Ll"
    / "Lm"
    / "Lo"
    / "Logical_Order_Exception"
    / "Lt"
    / "Lu"
    / "Lycian"
    / "Lydian"
    / "M"
    / "Mahajani"
    / "Malayalam"
    / "Mandaic"
    / "Manichaean"
    / "Mc"
    / "Me"
    / "Meetei_Mayek"
    / "Mende_Kikakui"
    / "Meroitic_Cursive"
    / "Meroitic_Hieroglyphs"
    / "Miao"
    / "Mn"
    / "Modi"
    / "Mongolian"
    / "Mro"
    / "Myanmar"
    / "N"
    / "Nabataean"
    / "Nd"
    / "New_Tai_Lue"
    / "Nko"
    / "Nl"
    / "No"
    / "Noncharacter_Code_Point"
    / "Ogham"
    / "Ol_Chiki"
    / "Old_Italic"
    / "Old_North_Arabian"
    / "Old_Permic"
    / "Old_Persian"
    / "Old_South_Arabian"
    / "Old_Turkic"
    / "Oriya"
    / "Osmanya"
    / "Other_Alphabetic"
    / "Other_Default_Ignorable_Code_Point"
    / "Other_Grapheme_Extend"
    / "Other_ID_Continue"
    / "Other_ID_Start"
    / "Other_Lowercase"
    / "Other_Math"
    / "Other_Uppercase"
    / "P"
    / "Pahawh_Hmong"
    / "Palmyrene"
    / "Pattern_Syntax"
    / "Pattern_White_Space"
    / "Pau_Cin_Hau"
    / "Pc"
    / "Pd"
    / "Pe"
    / "Pf"
    / "Phags_Pa"
    / "Phoenician"
    / "Pi"
    / "Po"
    / "Ps"
    / "Psalter_Pahlavi"
    / "Quotation_Mark"
    / "Radical"
    / "Rejang"
    / "Runic"
    / "S"
    / "STerm"
    / "Samaritan"
    / "Saurashtra"
    / "Sc"
    / "Sharada"
    / "Shavian"
    / "Siddham"
    / "Sinhala"
    / "Sk"
    / "Sm"
    / "So"
    / "Soft_Dotted"
    / "Sora_Sompeng"
    / "Sundanese"
    / "Syloti_Nagri"
    / "Syriac"
    / "Tagalog"
    / "Tagbanwa"
    / "Tai_Le"
    / "Tai_Tham"
    / "Tai_Viet"
    / "Takri"
    / "Tamil"
    / "Telugu"
    / "Terminal_Punctuation"
    / "Thaana"
    / "Thai"
    / "Tibetan"
    / "Tifinagh"
    / "Tirhuta"
    / "Ugaritic"
    / "Unified_Ideograph"
    / "Vai"
    / "Variation_Selector"
    / "Warang_Citi"
    / "White_Space"
    / "Yi"
    / "Z"
    / "Zl"
    / "Zp"
    / "Zs"

*/

AnyMatcher ← "." {
    any := ast.NewAnyMatcher(c.astPos(), ".")
    return any, nil
}

CodeBlock ← "{" Code "}" {
    pos := c.astPos()
    cb := ast.NewCodeBlock(pos, string(c.text))
    return cb, nil
}

Code ← ( ( ![{}] SourceChar )+ / "{" Code "}" )*

__ ← ( Whitespace / EOL / Comment )*
_ ← ( Whitespace / MultiLineCommentNoLineTerminator )*

Whitespace ← [ \t\r]
EOL ← '\n'
EOS ← __ ';' / _ SingleLineComment? EOL / __ EOF

EOF ← !.

